// import "module-alias/register";
import { Telegraf, Context, Types, Markup } from "telegraf";
import "dotenv/config";
import { Update, Message, User } from "typegram";
import { Config as config } from "./config";
import { Emails, State } from "./Email";
const nodemailer = require("nodemailer");
const needle = require("needle");
const fs = require("fs");

import {
  countryKeyboard,
  phoneKeyboard,
  regionKeyboard,
  serviceKeyboard,
} from "./keyboards";
// import { russian, tadjik, uzbek } from "./texts";
import { ELanguage, LanguagesJsonParser } from "./jsonParser";

type BaseMessage = Update.New &
  Update.NonChannel &
  Message & {
    text?: string;
    forward_from?: User;
    voice?: unknown;
    sticker?: unknown;
    document?: TgAsset;
    photo?: unknown[];
    caption: string;
    contact?: { phone_number: unknown };
  };

type TgMessage = BaseMessage & {
  reply_to_message?: BaseMessage;
};

type TgAsset = {
  file_id: string;
};

export class BotStrategies {
  private languagesJsonParser = new LanguagesJsonParser(
    __dirname.split("/").slice(0, -2).join("/") + "/src/bot/texts.json"
  );
  constructor(private readonly bot: Telegraf<Context>) {}

  async Initialize() {
    await this.bot.telegram.setMyCommands([
      { command: "start", description: "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∏—Å—å–º–æ –µ—â—ë —Ä–∞–∑" },
    ]);

    // await this.bot.telegram.setChatDescription("–≤–æ—Ç —Ç–∞–∫–º–æ–≥—É");
    this.bot.start((ctx: Context) => this.start(ctx));
    this.bot.hears(/\/settj1/, (ctx: Context) => {
      const text = (ctx.message as TgMessage).text
        .split(" ")
        .slice(1, -1)
        .join(" ");
      this.languagesJsonParser.set(ELanguage.TJ, text);
    });
    this.bot.hears(/\/setuz/, (ctx: Context) => {
      const text = (ctx.message as TgMessage).text
        .split(" ")
        .slice(1, -1)
        .join(" ");
      this.languagesJsonParser.set(ELanguage.UZ, text);
    });
    this.bot.hears(/\/setru1/, (ctx: Context) => {
      const text = (ctx.message as TgMessage).text
        .split(" ")
        .slice(1, -1)
        .join(" ");
      this.languagesJsonParser.set(ELanguage.RU, text);
    });
    // this.bot.hears(/\/mail1370/, (ctx: Context) => this.getClients(ctx));

    // this.clearBD();
    // this.bot.catch(console.error);
    this.bot.action("patent", async (ctx) => this.handleService(ctx, "–ü–∞—Ç–µ–Ω—Ç"));
    this.bot.action("work", async (ctx) => this.handleService(ctx, "–†–∞–±–æ—Ç–∞"));
    this.bot.action("propiska", async (ctx) =>
      this.handleService(ctx, "–ü—Ä–æ–ø–∏—Å–∫–∞")
    );
    this.bot.action("insurance", async (ctx) =>
      this.handleService(ctx, "–°—Ç—Ä–∞—Ö–æ–≤–∫–∞")
    );
    this.bot.action("advocate", async (ctx) =>
      this.handleService(ctx, "–ê–¥–≤–æ–∫–∞—Ç")
    );
    this.bot.action("dolg", async (ctx) =>
      this.handleService(ctx, "–°–ø–∏—Å–∞—Ç—å –¥–æ–ª–≥")
    );
    this.bot.action("otherService", async (ctx) =>
      this.handleService(ctx, "–î—Ä—É–≥–æ–µ")
    );

    this.bot.action("tadjikistan", async (ctx) =>
      this.handleCountry(ctx, "–¢–∞–¥–∂–∏–∫–∏—Å—Ç–∞–Ω", ELanguage.TJ)
    );
    this.bot.action("uzbekistan", async (ctx) =>
      this.handleCountry(ctx, "–£–∑–±–µ–∫–∏—Å—Ç–∞–Ω", ELanguage.UZ)
    );
    this.bot.action("azerbaidjan", async (ctx) =>
      this.handleCountry(ctx, "–ê–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω", ELanguage.RU)
    );
    this.bot.action("russia", async (ctx) =>
      this.handleCountry(ctx, "–†–æ—Å—Å–∏—è", ELanguage.RU)
    );
    this.bot.action("otherCountry", async (ctx) =>
      this.handleCountry(ctx, "–î—Ä—É–≥–∞—è —Å—Ç—Ä–∞–Ω–∞", ELanguage.RU)
    );

    this.bot.action("spb", async (ctx) =>
      this.handleRegion(ctx, "–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥")
    );
    this.bot.action("spb_region", async (ctx) =>
      this.handleRegion(ctx, "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å")
    );
    this.bot.action("otherRegion", async (ctx) =>
      this.handleRegion(ctx, "–î—Ä—É–≥–æ–π")
    );

    this.bot.on("message", (ctx: Context) => this.stateHandler(ctx));

    this.bot.catch(console.error);

    console.log("BotStrategies initialization ended.");
  }

  private async handleCountry(ctx, country: string, lg: ELanguage) {
    try {
      const text = this.languagesJsonParser.get(lg);
      ctx.editMessageText(text, serviceKeyboard);
      await Emails.updateOne(
        { userTelegramId: ctx.update.callback_query.from.id },
        { $set: { country: country } }
      );
      console.log(ctx);
    } catch (e) {
      console.log(e);
    }
  }

  private async handleRegion(ctx, region: string) {
    try {
      ctx.editMessageText("–ì—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–æ?", countryKeyboard);
      await Emails.updateOne(
        { userTelegramId: ctx.update.callback_query.from.id },
        { $set: { region: region } }
      );
      console.log(ctx);
    } catch (e) {
      console.log(e);
    }
  }

  private async handleService(ctx, service: string) {
    try {
      ctx.editMessageText("–ö–∞–∫ –í–∞—Å –∑–æ–≤—É—Ç?");
      await Emails.updateOne(
        { userTelegramId: ctx.update.callback_query.from.id },
        { $set: { type: service, state: State.sendName } }
      );
    } catch (e) {
      console.log(e);
    }
  }

  private async stateHandler(ctx: Context) {
    const message = ctx.message as TgMessage;
    const userId = message.from.id;
    try {
      const user = await Emails.findOne({ userTelegramId: userId });
      console.log(user);
      if (!user) this.start(ctx);
      switch (user.state) {
        case State.sendName:
          const res1 = await Emails.updateOne(
            { userTelegramId: userId },
            { $set: { userName: message.text, state: State.sendPhone } }
          );
          console.log("—Å—Ç–µ–π—Ç —Å—Ç–∞–ª —Åendphone  ", res1);
          ctx.reply(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ üëáüèº",
            phoneKeyboard
          );
          break;
        case State.sendPhone:
          if (message?.contact) {
            console.log(message.contact.phone_number);
            await Emails.updateOne(
              { userTelegramId: userId },
              {
                $set: {
                  phone: message.contact.phone_number,
                  state: State.default,
                },
              }
            );
            const res = await await Emails.findOne({ userTelegramId: userId });
            await this.sendEmail(res);
            ctx.reply("–ó–∞—è–≤–∫–∞ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.");
          } else {
            ctx.reply(
              "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ üëáüèº",
              phoneKeyboard
            );
            return;
          }
          break;
        // case State.sendDoc:
        //   if (!(await this.validateDoc(message))) {
        //     ctx.reply("–û—Ç–ø—Ä–∞–≤—å—Ç–µ PDF —Å–∫–∞–Ω –ø–∞—Å–ø–æ—Ä—Ç–∞!");
        //     return;
        //   } else {
        //     ctx.reply("–ü–∏—Å—å–º–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!");
        //     await Emails.updateOne(
        //       { userTelegramId: userId },
        //       { $set: { doc: message.document.file_id, state: State.default } }
        //     );
        //     const res = await await Emails.findOne({ userTelegramId: userId });
        //     await this.sendEmail(res);
        //   }
        //   break;
        // case State.sendDoc:
        //   if (!(await this.validateDoc(message))) {
        //     ctx.reply("–û—Ç–ø—Ä–∞–≤—å—Ç–µ PDF —Å–∫–∞–Ω –ø–∞—Å–ø–æ—Ä—Ç–∞!");
        //     return;
        //   } else {
        //     ctx.reply("–ü–∏—Å—å–º–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!");
        //     await Emails.updateOne(
        //       { userTelegramId: userId },
        //       { $set: { doc: message.document.file_id, state: State.default } }
        //     );
        //     const res = await await Emails.findOne({ userTelegramId: userId });
        //     await this.sendEmail(res);
        //   }
        //   break;
        case State.default:
          ctx.reply("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –≤—ã—à–µ");
          break;
      }
    } catch (e) {
      ctx.reply("–ì–¥–µ-—Ç–æ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µüòî");
    }
  }

  private async clearBD() {
    await Emails.remove();
  }

  // private async validateDoc(message) {
  //   if (message?.document) {
  //     const doc = message.document.file_id;
  //     const fileInfo = await this.bot.telegram.getFile(doc);
  //     const fileLink = await this.bot.telegram.getFileLink(doc);
  //     console.log(fileInfo, "________---_____", fileLink);
  //     const fileExtension = fileInfo.file_path.split(".").splice(-1)[0];
  //     if (fileExtension == "pdf") {
  //       console.log(fileExtension);
  //       return true;
  //     } else {
  //       return false;
  //     }
  //   } else if (message?.photo) {
  //     return false;
  //   }
  //   return false;
  // }

  // private async cancelSending(ctx: Context) {
  //   const message = ctx.message as TgMessage;
  //   console.log(message);
  //   const userId = message.from.id;
  //   try {
  //     await Emails.deleteOne({ userTelegramId: userId });
  //     const keyboard = Markup.keyboard(["–û—Ç–ø—Ä–∞–≤–∏—Ç—å"]).resize(true);
  //     ctx.reply("–ü–∏—Å—å–º–æ —É–¥–∞–ª–µ–Ω–æ. –•–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ?");
  //   } catch (e) {
  //     console.log(e);
  //   }
  // }

  // private async copyDocument(doc) {
  //   // console.log(doc);
  //   const fileInfo = await this.bot.telegram.getFile(doc);
  //   const fileLink = await this.bot.telegram.getFileLink(doc);
  //   console.log(fileInfo, "________---_____", fileLink);
  //   const fileExtension = fileInfo.file_path.split(".").splice(-1)[0];
  //   console.log(fileExtension);
  //   const fileName = `${doc}.${fileExtension}`;
  //   // console.log("openfile_____________\n",fs.open(fileName, "r"))
  //   await needle
  //     .get(`${fileLink.href}`)
  //     .pipe(fs.createWriteStream(`documents/${fileName}`))
  //     .on("done", function (err) {
  //       console.log("Pipe finished!");
  //     });
  //   return [fileName, fileExtension];
  // }

  private async sendEmail(mail) {
    console.log(__dirname);
    try {
      // console.log("–¥–æ–ø—É—Å—Ç–∏–º –æ—Ç–ø—Ä–∞–≤–∏–ª–æ—Å—å");
      // // console.log(mail);
      // // const [fileName, ext] = await this.copyDocument(mail.doc);
      // // console.log("filename is:", fileName, "\n", ext, "\n nigger");
      // Generate test SMTP service account from ethereal.email
      // Only needed if you don't have a real mail account for testing

      // create reusable transporter object using the default SMTP transport
      console.log(config.mailHost);
      let transporter = nodemailer.createTransport({
        host: config.mailHost,
        port: config.mailPort,
        secure: true, // true for 465, false for other ports
        auth: {
          user: config.mailUser,
          pass: config.mailPass,
        },
      });

      // // const dirname = __dirname.split("/").slice(0, -2).join("/");
      // // console.log(dirname);
      let text = "default";
      if (mail?.userName) {
        text = mail.userName.split(" ").join("_");
      }
      // send mail with defined transport object
      let info = await transporter.sendMail({
        from: "vipkrutoi@mail.ru", // sender address
        to: "vipkrutoi@mail.ru", // list of receivers
        // to: "vipkrutoi@mail.ru",
        subject: mail.userName, // Subject line
        text: `–¢–µ–º–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è: ${mail.type} \n–ì—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–æ: ${mail.country} \n–†–µ–≥–∏–æ–Ω –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è: ${mail.region} \n–§–ò–û: ${mail.userName} \n–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞: ${mail.phone}`, // plain text body
        //html: `${mail.text}`, // html body
        // // attachments: {
        // //   filename: `${text}.${ext}`,
        // //   path: dirname + `/documents/${fileName}`,
        // //   cid: `${fileName}`, // should be as unique as possible
        // // },
      });

      // fs.unlink(dirname + `/documents/${fileName}`, (err) => {
      //   if (err) throw err; // –Ω–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª
      //   console.log("–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω");
      // });

      console.log("Message sent: %s", info);
      return true;
    } catch (e) {
      console.log(e);
    }
  }

  private async start(ctx: Context) {
    try {
      await Emails.deleteOld();
      const message = ctx.message as TgMessage;
      const userId = message.from.id;

      await Emails.deletePrevious(userId as unknown as string);

      console.log(message);

      let greeting = "–î–æ–±—Ä—ã–π –¥–µ–Ω—å";

      await new Emails({ userTelegramId: userId }).save();

      if (message?.from?.first_name)
        greeting += ", " + message.from.first_name + "!\n";
      else greeting += "!\n";

      // const keyboard = Markup.keyboard(["–û—Ç–ø—Ä–∞–≤–∏—Ç—å"]).resize(true);
      await this.bot.telegram.sendMessage(
        userId,
        greeting + "–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è.\n",
        regionKeyboard
      );
    } catch (e) {
      console.log(e);
      ctx.reply("Unknown error accured: ", e.message);
    }
  }
}
